---
title: "Using R to Compute The Rectangular Statistical Cartogram"
author: "Christian Panse"
date: "`r Sys.Date()`"
bibliography:
  - recmap.bib
csl: ieee.csl
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{recmap primer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This package contains a C++ implementation of the recmap algorithm 
[[@recmap]](http://dx.doi.org/10.1109/INFVIS.2004.57).
The input consist of a map represented by overlapping rectangles.
Furthermore the algorithm reqires as input for each map region:

- a tuple of (x, y) values corresponding to the (longitude, latitude) position 
- a tuple of (dx, dy) of expansion along (longitude, latitude) 
- and a statistical value z.

The (x, y) coordinates represents the center of the minimal bounding boxes (MBB),
The coordinates of the MBB are derived by adding or substracting the (dx, dy) 
tuple accordingly. The tuple (dx, dy) defines also the ratio of the map region.
The statistical values define the desired area of each map region. 

The output is a rectangular cartogram where the map regions are:

- non overlapping, 
- connected, 
- ratio and area of each rectangle corresponds to the desired areas.
- rectangles are placed parallel to the axes

The construction heuristic  places the rectangles in a way that important 
spatial constraints, in particular

- the topology of the pseudo dual graph,
- the relative position of MBB centers.

are tried to be preserved.

The ratios are preserved and the area of each region corresponds to 
the as input given statistical value z.

The power of a cartogram based visualization is demonstrated below.

```{r fig.width=7, fig.retina=2, fig.align='left', fig.cap="Rectangular Cartogram of the U.S. election 2004; The area corresponds to the number of electors (color indicates the party red: democrates / blue: republican; the color intensity ~ outcome of the vote.). The graphic was computed by using the original implementation of the construction heuristic RecMap MP2 introduced in [@recmap].", echo=FALSE, warning=FALSE, comment="ccc", error=FALSE, message=FALSE}

library(recmap)
op<-par(mar=c(0,0,0,0), bg='black')
recmap:::.draw_recmap_us_state_ev()
par(op)
```


# The Algorithm

## Input using the U.S. `state` Facts and Figures Dataset

```{r}
usa <- data.frame(x=state.center$x, 
    y = state.center$y, 
    # make the rectangles overlapping by correcting lines of longitude distance
    dx = sqrt(state.area) / 2 / (0.8 * 60 * cos(state.center$y*pi/180)), 
    dy = sqrt(state.area) / 2 / (0.8 * 60) , 
    z = sqrt(state.area),
    name = state.name)
```

## Determine the Desired Areas

The desired area $\tilde{A_j}$ of a map region  $r_j$ is defined as
$$\tilde{A_j}= z_j \cdot \frac {\sum_{i=1}^{k}A(r_j)} {\sum_{j=1}^{k} z_{j}}$$ (CTRL-C CTRL-V from [@cartodraw]). 

## Compute Pseudo Dual Graph (PD)

```{r fig.width=7, fig.height=3}
op<-par(mfrow=c(1,1), mar=c(0,0,0,0))
library(recmap)
plot_recmap(M <- usa[!usa$name %in% c("Hawaii", "Alaska"), ],  col.text = 'black', lwd=2)
#plot_recmap(C<-recmap(M), cex=0.5)
```

## Construction Heuristic

- Determine the core region
- Place region by region along DFS skeleton of pseudo dual starting withe the 
core region
- If a rectangle can not be placed find a feasible solution (no overlapping 
regions) by placing it next to a neighbour use BFS


A local placement function can place an rectangle a around a given rectangle b of any angle between $[-\pi,\pi]$.
There are special cases for quad I, II, III, and IV indicated by different colors in the gaphic below.

```{r echo=FALSE, fig.width=2, fig.height=2, fig.align='center'}

draw_and_place_rectangle <- function(alpha=0.0, a.x=2, a.y=-5, a.dx = 20, a.dy = 5, b.dx=1.5, b.dy=5, ...){
   
   rect(a.x - a.dx - b.dx, a.y - a.dy - b.dy, 
        a.x + a.dx + b.dx, a.y + a.dy + b.dy, 
        lwd=3, border='grey')
  
   rect(a.x - a.dx, a.y - a.dy, 
        a.x + a.dx, a.y + a.dy)
   
  
  c <- recmap:::place_rectanle(a.x, a.y, a.dx, a.dy, b.dx, b.dy, alpha)

   rect(c$x - c$dx, c$y - c$dy, c$x + c$dx, c$y + c$dy, ...)
}

op <- par(mar=c(0,0,0,0))
plot(0,0 , xlim=c(-25,25), ylim=c(-25,25), asp=1, xlab='', ylab='', axes=FALSE); abline(v=0,h=0)
r<-lapply(seq(0, pi/2, length=90), function(alpha){draw_and_place_rectangle(alpha, col='#DD001199', border='#88888877')})
r<-lapply(seq(pi/2, pi, length=90), function(alpha){draw_and_place_rectangle(alpha, col='#00DD1199', border='#88888877')})
r<-lapply(seq(-pi, -pi/2, length=90), function(alpha){draw_and_place_rectangle(alpha, col='#11DDDD99', border='#88888877')})
r<-lapply(seq(-pi/2, 0, length=90), function(alpha){draw_and_place_rectangle(alpha, col='#0011DD99', border='#88888877')})

par(op)
```

## Objective Functions

### Topology 

The topology error is an indicator of the deviation of
the neighborhood relationships.
The error is computed by counting the differences 
beween dual graphs or adjacency graphs of map and cartogram 
(for a more formal definition see [@recmap]).

### Relative Region Positions 

Measures the angle difference between alles region centers.

### Empty Space

The empty space is the ratio between the areas of the regions and the area of 
the global minimal bounding box.

## Output

The output is again a `data.frame`.

```{r}
head(Cartogram <- recmap(Map <- usa[!usa$name %in% c("Hawaii", "Alaska"), ]))
```

# Application

## `state.x77[, 'Population']`

```{r fig.width=8, fig.height=4, fig.align='center', fig.cap="Area ~ population estimate as of July 1, 1975;"}

op<-par(mfrow=c(1,1), mar=c(0,0,0,0))
usa$z <- state.x77[, 'Population']
M <- usa[!usa$name %in% c("Hawaii", "Alaska"), ]
plot_recmap(Cartogram.Population <- recmap(M[order(M$x),]), col.text = 'black', lwd=2)
```

```{r fig.width=8, fig.height=4, fig.align='center', fig.cap="Area ~ population estimate as of July 1, 1975; a better index order has been determined by a meta heuristic."}
op<-par(mfrow=c(1,1), mar=c(0,0,0,0))
smp <- c(20,47,4,40,9,6,32,33,3,10,34,22,2,28,15,12,39,7,42,45,19,13,43,30,24,
         25,11,17,37,41,26,29,21,35,8,36,14,16,31,48,46,38,23,18,1,5,44,27)
plot_recmap(Cartogram.Population <- recmap(M[smp,]), col.text = 'black', lwd=2)
```

## `state.x77[, 'Income']`

```{r fig.width=8, fig.height=4, fig.align='center', fig.cap="Area ~ capita income (1974);"}
op<-par(mfrow=c(1,1), mar=c(0,0,0,0))
usa$z <- state.x77[, 'Income']
M <- usa[!usa$name %in% c("Hawaii", "Alaska"), ]
plot_recmap(Cartogram.Income <- recmap(M[order(M$x),]), col.text = 'black', lwd=2)
```

## `state.x77[, 'Frost']`

```{r fig.width=8, fig.height=4, fig.align='center', fig.cap="Area ~ mean number of days with minimum temperature below freezing (1931â€“1960) in capital or large city;" }
op<-par(mfrow=c(1,1), mar=c(0,0,0,0))
usa$z <- state.x77[, 'Frost'] 
M <- usa[!usa$name %in% c("Hawaii", "Alaska"), ]
plot_recmap(Cartogram.Income <- recmap(M[order(M$x),]), col.text = 'black', lwd=2)
```


## Syntetic Checker Boards

The in [@cartodraw] introduced checker board examples will demonstarte the 
strength and weakness of the method.

```{r}
recmap:::.checker_board(2)
```

```{r fig.width=7, fig.height=2.5, fig.align='center', fig.retina=2}
op<-par(mar=c(0,0,0,0), 
        mfrow=c(1, 4), 
        bg='white')

lapply(c(2,8), function(n){
  Map <- recmap:::.checker_board(n)
  Cartogram <- recmap(Map)
  
  plot_recmap(Map, col=c('white','white','white','black')[Map$z])
  plot_recmap(Cartogram, col=c('white','white','white','black')[Map$z])
  
  sum(Map$dx * Map$dy * 4) == sum(Cartogram$dx * Cartogram$dy * 4)
})

par(op)
```

# Wishlist

## C++/R

- ReferenceClasses
- refactoring of C++ code into C++11 code

## RecMap

- define core polygon
- provide example for meta heutistic
- use sorted arrays and binary search when checking MBB overlap
- allow multiple connected components dual graph, e.g., world map


# History 

The work on recmap was initiated by understanding the limits of contiguous 
cartogram drawing [@cartodraw] and after studying the visualizations
drawn by Erwin Raisz [@ErwinRaisz].
While the purpose of the first implementation [@recmap] was more a feasibility 
check on how computer generated rectangular cartograms could look like and 
if this could be done  at all, 
this R package tries to make one rectangular cartogram algorithm available for 
a broader range of users. This means it is easy to generate input, e.g, no 
complex polygon mesh, maintainable code, and the algorithm is made robust 
to the price of not having all featues implemented.
Recent research publication on rectangular cartograms drawing include 
[@Speckmann2004], [@Speckmann2007], [@Speckmann2012].

#References

