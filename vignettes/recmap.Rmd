---
title: "Using R to Compute The Rectangular Statistical Cartogram"
author: "Christian Panse"
date: "`r Sys.Date()`"
bibliography:
  - recmap.bib
csl: ieee.csl
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{recmap primer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This package contains a C++ implementation of the recmap algorithm 
[[@recmap]](http://dx.doi.org/10.1109/INFVIS.2004.57).
The input consist of a map represented by overlapping rectangles.
Furthermore the algorithm reqires as input for each map region:

- a tuple of (x, y) values corresponding to the (longitude, latitude) position 
- a map ratio, 
- and a statistical value z.

The (x, y) coordinates represents the center of the minimal bounding boxes (MBB), 
the ratio the longitude / latitude 
ratios, and the  statistical values define the desired 
area of each map region. 

The output is a rectangular cartogram where the map regions are:

- non overlapping, 
- connected, 
- ratio and area of each rectangle corresponds to the desired areas.
- rectangles are placed parallel to the axes

The construction heuristic  places the rectangles in a way that important 
spatial constraints, in particular

- the topology of the pseudo dual graph,
- the relative position of MBB centers.

are tried to be preserved.

The ratios are preserved and the area of each region corresponds to 
the as input given statistical value z.


```{r fig.width=7, fig.retina=2, fig.align='center', fig.cap="Rectangular Cartogram of the U.S. election 2004; The area corresponds to the number of electors. The graphic was computed by using the original implementation of the construction heuristic RecMap MP2 introduced in [@recmap]."}

library(recmap)
op<-par(mar=c(0,0,0,0), bg='black')
recmap:::.draw_recmap_us_state_ev()
par(op)
```


# Example Data
```{r}
recmap:::.checker_board(2)
```

```{r fig.width=5, fig.height=5, fig.align='center'}


op<-par(mar=c(0,0,0,0), 
        mfrow=c(2,2), 
        bg='white')

res <- lapply(c(2, 4, 8, 64), function(n){plot.recmapFrame(recmap:::.checker_board(n))})

par(op)
```

# The Algorithm

## Desired Areas

The desired area $\tilde{A_j}$ of a map region  $r_j$ is defined as
$\tilde{A_j}= z_j \cdot \frac {\sum_{i=1}^{k}A(r_j)} {\sum_{j=1}^{k} z_{j}}$ (see also [@cartodraw]). 

## Compute Pseudo Dual Graph (PD)

## Determine the Core Region

## Place rectangle by rectangle

### Global along DFS Skeleton of PD

### Local 

local placement function $f: (x0,y0,dx0,dy0,dx1,dy1,[-\pi,\pi]) \rightarrow (\mathbb{R}, \mathbb{R})$.
There are special cases for quad I, II, III, and IV indicated by different colors.

```{r echo=FALSE, fig.width=3, fig.height=3, fig.align='center'}

draw_and_place_rectangle <- function(alpha=0.0, a.x=2, a.y=-5, a.dx = 20, a.dy = 5, b.dx=1.5, b.dy=5, ...){
   
   rect(a.x - a.dx - b.dx, a.y - a.dy - b.dy, 
        a.x + a.dx + b.dx, a.y + a.dy + b.dy, 
        lwd=3, border='grey')
  
   rect(a.x - a.dx, a.y - a.dy, 
        a.x + a.dx, a.y + a.dy)
   
   c <- recmap:::place_rectanle(a.x, a.y, a.dx, a.dy, b.dx, b.dy, alpha)
  
   rect(c$x - c$dx, c$y - c$dy, c$x + c$dx, c$y + c$dy, ...)
}

op <- par(mar=c(0,0,0,0))
plot(0,0 , xlim=c(-25,25), ylim=c(-25,25), asp=1, xlab='', ylab='', axes=FALSE); abline(v=0,h=0)
r<-lapply(seq(0, pi/2, length=90), function(alpha){draw_and_place_rectangle(alpha, col='#DD001199', border='#88888877')})

r<-lapply(seq(pi/2, pi, length=90), function(alpha){draw_and_place_rectangle(alpha, col='#00DD1199', border='#88888877')})

r<-lapply(seq(-pi, -pi/2, length=90), function(alpha){draw_and_place_rectangle(alpha, col='#11DDDD99', border='#88888877')})

#r<-lapply(seq(3 * pi/2, 2 * pi, length=90), function(alpha){draw_and_place_rectangle(alpha, col='#0011DD99', border='#88888877')})
r<-lapply(seq(-pi/2, 0, length=90), function(alpha){draw_and_place_rectangle(alpha, col='#0011DD99', border='#88888877')})

par(op)

```

## Objective Functions

### Topology 

### Relative Position

## Evaluation 

### Proof of Concept

```{r}
chess_board_fun <- function(n=8){
chess_board <- recmap:::.checker_board(n)
head(chess_board.area <- sum(chess_board$dx * chess_board$dy * 4))

chess_board_cartogram <- recmap:::recmap(chess_board)

table(chess_board_cartogram$dx * chess_board_cartogram$dy * 4)

(chess_board_cartogram.area <- sum(chess_board_cartogram$dx * chess_board_cartogram$dy * 4))

chess_board_cartogram.area == chess_board.area}
```

# Benchmark

# Addendum 

The work on recmap was initiated by understanding the limits of contiguous 
cartograms generation [@cartodraw] and after studying the visualizations
drawn by Erwin Raisz [@ErwinRaisz].
While the purpose of the first implementation [@recmap] was more a feasibility 
check on how computer generated rectangular cartograms could look like and 
if this could be done  at all, 
this R package tries to make one rectangular cartogram algorithm available for 
a broader range of users. This means it is easy to generate input, e.g, no 
complex polygon mesh, maintainable code, and the algorithm is made robust 
to the price of not having all featues implemented.
Recent research publication on rectangular cartograms drawing include [@Speckmann2004], [@Speckmann2007], [@Speckmann2012].

#References

