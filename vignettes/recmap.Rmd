---
title: "On Rectangular Map Approximations"
author: "Christian Panse"
date: "`r Sys.Date()`"
bibliography:
  - recmap.bib
csl: ieee.csl
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{recmap primer}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

# Introduction

This package contains a C++ implementation of the recmap algorithm 
[[@recmap]](http://dx.doi.org/10.1109/INFVIS.2004.57).
The input contains for each map region:

- a tuple of (x, y) values corresponding to the (longitude, latitude) position 
- a map ratio, 
- and a statistical value z.

The (x, y) coordinates represents the center of the minimal bounding boxes (MBB), 
the ratio the longitude / latitude 
ratios, and the  statistical values define the desired 
area of each map region. 

The output is a rectangular cartogram where the map regions are:

- non overlapping, 
- connected, 
- ratio and area of each rectangle corresponds to the desired areas.
- rectangles are parallel to the axes

The construction heuristic places the rectangles in a way that important 
spatial constraints, in particular

- the topology of the pseudo dual graph,
- the relative position of MBB centers, 
- and the ratios of each input map regions.

are tried to be preserved


```{r fig.width=7, fig.retina=2, fig.align='center', fig.cap="Rectangular Cartogram of the U.S. election 2004; The area corresponds to the number of electors. The graphic was computed by using the original implementation of the construction heuristic RecMap MP2 introduced in [@recmap]."}

library(recmap)
op<-par(mar=c(0,0,0,0), bg='black')
recmap:::.draw_recmap_us_state_ev()
par(op)
```


# Example Data
```{r}
recmap:::.checker_board(2)
```

```{r fig.width=5, fig.height=5, fig.align='center'}


op<-par(mar=c(0,0,0,0), 
        mfrow=c(2,2), 
        bg='white')

res <- lapply(c(2, 4, 8, 64), function(n){plot.recmapFrame(recmap:::.checker_board(n))})

par(op)
```

# The Algorithm

## Desired Areas

The desired area $\tilde{A_j}$ of a map region  $r_j$ is defined as
$\tilde{A_j}= z_j \cdot \frac {\sum_{i=1}^{k}A(r_j)} {\sum_{j=1}^{k} z_{j}}$ (see also [@cartodraw]). 

## Compute Pseudo Dual Graph (PD)

## Determine the Core Region

## Place rectangle by rectangle

### Global along DFS Skeleton of PD

### Local 

local placement function taking $\alpha$  with  $0 \leq \alpha  \le 2\pi$ as input

```{r echo=FALSE, message=FALSE, fig.width=5, fig.height=5, fig.align='center'}

place <- function(alpha=0.0, c.dx = 5, c.dy = 5, x=2, y=-2,dx=2.5, dy=5){
 
  
  c.x <- 0
  c.y <- 0
  
  plot(x, y , xlim=c(-25,25), ylim=c(-25,25), asp=1)
  rect(x - dx - c.dx, y - dy - c.dy, x+dx+c.dx, y+dy+c.dy, lwd=3,border='grey')
  rect(x - dx, y - dy, x + dx, y + dy)
  # case 1
  if (sin(alpha) >= 0 & cos(alpha) >= 0){
  
    c.x.1 <- ((c.dy + dy) * tan(alpha) ) + x
    c.y.1 <- (c.dy + dy)  + y
    
    c.x.2 <- c.dx + dx + x
    c.y.2 <- ((c.dy + dy) * tan(pi/2 - alpha))  + y
    points(c.x.1, c.y.1, col='green')
    points(c.x.2, c.y.2, col='red')
    
    if (c.y.2 >= y + c.dy + dy){
      c.x <- c.x.1
      c.y <- c.y.1
    }else{
      c.x <- c.x.2
      c.y <- c.y.2
    }
  }
  
  rect(c.x - c.dx, c.y - c.dy, c.x + c.dx, c.y + c.dy)
  #data.frame(c.x, c.y)
}

#par(ask=TRUE)
place(pi/2/3)
#lapply(alpha <- seq(0, pi/2, length=40), function(a){place(a)})

```

## Objective Functions

### Topology 

### Relative Position

## Evaluation 

### Proof of Concept

```{r}
chess_board_fun <- function(n=8){
chess_board <- recmap:::.checker_board(n)
head(chess_board.area <- sum(chess_board$dx * chess_board$dy * 4))

chess_board_cartogram <- recmap:::recmap(chess_board)

table(chess_board_cartogram$dx * chess_board_cartogram$dy * 4)

(chess_board_cartogram.area <- sum(chess_board_cartogram$dx * chess_board_cartogram$dy * 4))

chess_board_cartogram.area == chess_board.area}
```

# Benchmark


#References

